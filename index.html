<!doctype html>
<html lang="hi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Subway Surfers 3D (Three.js)</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #0c0f14;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: #e9edf1;
        overflow: hidden;
      }
      #hud {
        position: fixed;
        top: 12px;
        left: 12px;
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 10;
        user-select: none;
        pointer-events: none;
      }
      .chip {
        background: rgba(15, 22, 33, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 8px 12px;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
        font-weight: 600;
      }
      #overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 12px;
        background: radial-gradient(1200px 600px at 50% 50%, rgba(0,0,0,0.45), rgba(0,0,0,0.85));
        z-index: 20;
        text-align: center;
      }
      #overlay.show { display: flex; }
      #overlay h1 { margin: 0; font-size: 38px; letter-spacing: 0.5px; }
      #overlay p { margin: 0 0 8px; opacity: 0.9; }
      #overlay .btn {
        pointer-events: auto;
        padding: 10px 16px;
        border-radius: 10px;
        background: #2a84ff;
        color: white;
        border: none;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(42,132,255,0.35);
      }
      .help {
        position: fixed;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 22, 33, 0.7);
        border: 1px solid rgba(255,255,255,0.08);
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        color: #c8d2e0;
        z-index: 10;
        user-select: none;
      }
      canvas { display:block; }
    </style>
  </head>
  <body>
    <div id="hud">
      <div id="score" class="chip">Score: 0</div>
      <div id="speed" class="chip">Speed: 0</div>
    </div>
    <div id="overlay">
      <h1>Game Over</h1>
      <p>Space दबाएं — Restart</p>
      <button id="restart" class="btn">Restart</button>
    </div>
    <div class="help">Controls: ← → lane | ↑ jump | ↓ slide | Space restart</div>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

      // ---------- Constants ----------
      const LANE_X = [-2.5, 0, 2.5];
      const WORLD_FORWARD = new THREE.Vector3(0, 0, -1);
      const GRAVITY = -45;
      const JUMP_VELOCITY = 18;
      const SLIDE_DURATION = 0.45;
      const TILE_LENGTH = 16;
      const TILES_VISIBLE = 20;
      const OBSTACLE_SPAWN_GAP_MIN = 10;
      const OBSTACLE_SPAWN_GAP_MAX = 22;
      const TRAIN_LENGTH = 22;
      const PLAYER_SIZE = new THREE.Vector3(1.2, 2.0, 2.0);
      const PLAYER_SLIDE_Y = 1.2;
      const CAMERA_OFFSET = new THREE.Vector3(0, 6.5, 12);

      // ---------- State ----------
      let renderer, scene, camera;
      let player, playerVelocityY = 0, isGrounded = true, isSliding = false, slideTimer = 0, targetLane = 1, currentLane = 1;
      let groundRoot, tiles = [], nextTileZ = 0;
      let obstacles = [];
      let gameSpeed = 14, distanceZ = 0, lastTime = 0, spawnZ = 50, nextSpawnAt = 0;
      let isGameOver = false;

      const scoreEl = document.getElementById('score');
      const speedEl = document.getElementById('speed');
      const overlayEl = document.getElementById('overlay');
      const restartBtn = document.getElementById('restart');

      // ---------- Helpers ----------
      function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }
      function randRange(min, max) { return Math.random() * (max - min) + min; }
      function aabbIntersects(a, b) {
        return (Math.abs(a.center.x - b.center.x) * 2 < (a.size.x + b.size.x)) &&
               (Math.abs(a.center.y - b.center.y) * 2 < (a.size.y + b.size.y)) &&
               (Math.abs(a.center.z - b.center.z) * 2 < (a.size.z + b.size.z));
      }

      function lerp(a, b, t) { return a + (b - a) * t; }

      // ---------- Scene Setup ----------
      function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0c0f14, 1);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0c0f14, 24, 120);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, CAMERA_OFFSET.y, CAMERA_OFFSET.z);
        scene.add(camera);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.6);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(8, 20, 10);
        dir.castShadow = false;
        scene.add(dir);

        const railMat = new THREE.MeshStandardMaterial({ color: 0x2a3340, metalness: 0.1, roughness: 0.9 });
        const stripeMat = new THREE.MeshBasicMaterial({ color: 0x3a92ff });
        groundRoot = new THREE.Group();
        scene.add(groundRoot);
        for (let i = 0; i < TILES_VISIBLE; i++) {
          const tile = new THREE.Group();
          const base = new THREE.Mesh(new THREE.BoxGeometry(12, 0.2, TILE_LENGTH), railMat);
          base.position.y = -0.1;
          base.receiveShadow = true;
          tile.add(base);
          // decorative stripes
          for (let l = 0; l < 3; l++) {
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, TILE_LENGTH), stripeMat);
            stripe.position.set(LANE_X[l], 0.02, 0);
            tile.add(stripe);
          }
          tile.position.z = -i * TILE_LENGTH;
          groundRoot.add(tile);
          tiles.push(tile);
          nextTileZ = Math.min(nextTileZ, tile.position.z - TILE_LENGTH);
        }

        // Side walls for aesthetics
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x151a21, roughness: 1 });
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 300), wallMat);
        leftWall.position.set(-8, 3, -120);
        scene.add(leftWall);
        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 300), wallMat);
        rightWall.position.set(8, 3, -120);
        scene.add(rightWall);

        // Player
        const playerMat = new THREE.MeshStandardMaterial({ color: 0xf2c14e, metalness: 0.2, roughness: 0.8 });
        player = new THREE.Mesh(new THREE.BoxGeometry(PLAYER_SIZE.x, PLAYER_SIZE.y, PLAYER_SIZE.z), playerMat);
        player.position.set(LANE_X[1], PLAYER_SIZE.y * 0.5, 2);
        player.castShadow = false;
        scene.add(player);

        // Input
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('resize', onResize);
        restartBtn.addEventListener('click', restart);

        // Initial spawn threshold
        nextSpawnAt = randRange(OBSTACLE_SPAWN_GAP_MIN, OBSTACLE_SPAWN_GAP_MAX);

        lastTime = performance.now();
        animate(lastTime);
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onKeyDown(e) {
        if (isGameOver && (e.code === 'Space')) { restart(); return; }
        if (isGameOver) return;
        if (e.code === 'ArrowLeft' || e.code === 'KeyA') moveLane(-1);
        else if (e.code === 'ArrowRight' || e.code === 'KeyD') moveLane(1);
        else if (e.code === 'ArrowUp' || e.code === 'KeyW') jump();
        else if (e.code === 'ArrowDown' || e.code === 'KeyS') slide();
      }

      function moveLane(dir) {
        targetLane = clamp(targetLane + dir, 0, 2);
      }

      function jump() {
        if (isGrounded && !isSliding) {
          isGrounded = false;
          playerVelocityY = JUMP_VELOCITY;
        }
      }

      function slide() {
        if (isGrounded && !isSliding) {
          isSliding = true;
          slideTimer = SLIDE_DURATION;
        }
      }

      function restart() {
        // Remove obstacles
        for (const obs of obstacles) scene.remove(obs.mesh);
        obstacles = [];
        // Reset state
        player.position.set(LANE_X[1], PLAYER_SIZE.y * 0.5, 2);
        playerVelocityY = 0; isGrounded = true; isSliding = false; slideTimer = 0; targetLane = 1; currentLane = 1;
        gameSpeed = 14; distanceZ = 0; spawnZ = 50; nextSpawnAt = randRange(OBSTACLE_SPAWN_GAP_MIN, OBSTACLE_SPAWN_GAP_MAX);
        isGameOver = false;
        overlayEl.classList.remove('show');
      }

      // ---------- Obstacle Spawning ----------
      function spawnObstacle() {
        const kind = Math.random() < 0.5 ? 'barrier' : 'train';
        if (kind === 'barrier') {
          const lane = Math.floor(Math.random() * 3);
          const height = 1.6;
          const width = 1.4;
          const depth = 1.2;
          const mat = new THREE.MeshStandardMaterial({ color: 0xff4757, roughness: 0.6 });
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat);
          mesh.position.set(LANE_X[lane], height * 0.5, -spawnZ);
          scene.add(mesh);
          // barcode stripes visual
          const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const stripes = new THREE.Group();
          for (let i = -2; i <= 2; i++) {
            const s = new THREE.Mesh(new THREE.BoxGeometry(0.08, height, 0.05), stripeMat);
            s.position.set(i * 0.22, 0, depth * 0.51);
            stripes.add(s);
          }
          mesh.add(stripes);
          obstacles.push({ type: 'barrier', lane, mesh, size: new THREE.Vector3(width, height, depth) });
        } else {
          const lane = Math.floor(Math.random() * 3);
          const width = 1.8;
          const height = 2.4;
          const depth = TRAIN_LENGTH;
          const mat = new THREE.MeshStandardMaterial({ color: 0x5f86ff, roughness: 0.7, metalness: 0.05 });
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat);
          mesh.position.set(LANE_X[lane], height * 0.5, -spawnZ - depth * 0.5);
          scene.add(mesh);
          obstacles.push({ type: 'train', lane, mesh, size: new THREE.Vector3(width, height, depth) });
        }
        nextSpawnAt = randRange(OBSTACLE_SPAWN_GAP_MIN, OBSTACLE_SPAWN_GAP_MAX);
      }

      // ---------- Game Loop ----------
      function animate(now) {
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        if (!isGameOver) update(dt);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      function update(dt) {
        // Speed progression
        gameSpeed = Math.min(34, gameSpeed + dt * 0.75);
        distanceZ += gameSpeed * dt;

        // Ground scrolling (recycle tiles)
        for (const tile of tiles) {
          tile.position.addScaledVector(WORLD_FORWARD, gameSpeed * dt);
          if (tile.position.z > TILE_LENGTH) {
            tile.position.z -= TILES_VISIBLE * TILE_LENGTH;
          }
        }

        // Camera follow
        const desiredCam = new THREE.Vector3(player.position.x, CAMERA_OFFSET.y, player.position.z + CAMERA_OFFSET.z);
        camera.position.x = lerp(camera.position.x, desiredCam.x, 1 - Math.pow(0.0001, dt));
        camera.position.y = lerp(camera.position.y, desiredCam.y, 1 - Math.pow(0.0001, dt));
        camera.position.z = lerp(camera.position.z, desiredCam.z, 1 - Math.pow(0.0001, dt));
        camera.lookAt(player.position.x, player.position.y + 0.6, player.position.z - 6);

        // Player lane smoothing
        currentLane = lerp(currentLane, targetLane, 1 - Math.pow(0.0015, dt));
        player.position.x = lerp(player.position.x, LANE_X[Math.round(currentLane)], 1 - Math.pow(0.0015, dt));

        // Jump / gravity
        if (!isGrounded) {
          playerVelocityY += GRAVITY * dt;
          player.position.y += playerVelocityY * dt;
          const minY = isSliding ? PLAYER_SLIDE_Y * 0.5 : PLAYER_SIZE.y * 0.5;
          if (player.position.y <= minY) {
            player.position.y = minY;
            playerVelocityY = 0;
            isGrounded = true;
          }
        }

        // Slide timer & temporary bounding box adjustment
        if (isSliding) {
          slideTimer -= dt;
          player.scale.y = 0.6;
          player.position.y = PLAYER_SLIDE_Y * 0.5;
          if (slideTimer <= 0) {
            isSliding = false;
            player.scale.y = 1.0;
            player.position.y = PLAYER_SIZE.y * 0.5;
          }
        }

        // Spawn obstacles as distance passes threshold
        if (distanceZ >= spawnZ) {
          if (nextSpawnAt <= 0) nextSpawnAt = randRange(OBSTACLE_SPAWN_GAP_MIN, OBSTACLE_SPAWN_GAP_MAX);
          spawnObstacle();
          spawnZ += nextSpawnAt + TRAIN_LENGTH * 0.25;
        }

        // Move obstacles with world
        for (const obs of obstacles) {
          obs.mesh.position.addScaledVector(WORLD_FORWARD, gameSpeed * dt);
        }

        // Cleanup obstacles behind player
        const newList = [];
        for (const obs of obstacles) {
          if (obs.mesh.position.z < player.position.z + 8) {
            newList.push(obs);
          } else {
            scene.remove(obs.mesh);
          }
        }
        obstacles = newList;

        // Collision
        const playerBox = { center: player.position.clone(), size: new THREE.Vector3(PLAYER_SIZE.x, isSliding ? PLAYER_SIZE.y * 0.6 : PLAYER_SIZE.y, PLAYER_SIZE.z) };
        for (const obs of obstacles) {
          const size = obs.size;
          const center = obs.mesh.position.clone();
          const obsBox = { center, size };
          if (aabbIntersects(playerBox, obsBox)) {
            gameOver();
            break;
          }
        }

        // UI
        scoreEl.textContent = `Score: ${Math.floor(distanceZ)}`;
        speedEl.textContent = `Speed: ${gameSpeed.toFixed(1)}`;
      }

      function gameOver() {
        isGameOver = true;
        overlayEl.classList.add('show');
      }

      // Kickoff
      init();
    </script>
  </body>
  </html>

